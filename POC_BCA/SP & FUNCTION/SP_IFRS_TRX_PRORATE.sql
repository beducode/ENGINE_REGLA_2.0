CREATE OR REPLACE PROCEDURE  SP_IFRS_TRX_PRORATE
AS
	V_CURRDATE DATE;
	V_PREVDATE DATE;
	V_DIFF_DIGIT_DECIMAL NUMBER(32,6);
	V_FUNCROUND NUMBER(10);
	V_ROUND NUMBER(10);
BEGIN

	SELECT  CURRDATE , PREVDATE INTO V_CURRDATE, V_PREVDATE
	FROM    IFRS_PRC_DATE_AMORT;

	SELECT CAST(VALUE1 AS NUMBER(10))
		, CAST(VALUE2 AS NUMBER(10)) INTO V_ROUND, V_FUNCROUND
	FROM TBLM_COMMONCODEDETAIL
	WHERE COMMONCODE = 'SCM003';

	V_DIFF_DIGIT_DECIMAL := 0.1;

	DELETE FROM IFRS_TRX_FACILITY_DETAIL
	WHERE DOWNLOAD_DATE >= V_CURRDATE;

	COMMIT;

	UPDATE IFRS_TRX_FACILITY_HEADER
	SET STATUS='ACT'
		, REVID=NULL
		, TRX_DR_CR= SUBSTR(TRX_DR_CR, 1,1)
	WHERE DOWNLOAD_DATE =V_CURRDATE;

	COMMIT;

	 /*****************************
	 UNALOC FACILITY ON MATURITY DATE GO TO PNL
	 *****************************/

	UPDATE IFRS_TRX_FACILITY_HEADER
	SET STATUS = 'PNL'
	WHERE MATURITY_DATE = V_CURRDATE
		AND DOWNLOAD_DATE = V_CURRDATE
		AND STATUS = 'ACT'
		AND UNALOC > 0.00;

	COMMIT;

	-- =========================================================
	-- REVERSAL
	-- =========================================================
	EXECUTE IMMEDIATE 'TRUNCATE TABLE TMP_FACILITY_REVERSAL';

	INSERT INTO TMP_FACILITY_REVERSAL
	(
		PKID,
		TRX_CODE,
		TRX_DATE,
		FACILITY_NUMBER,
		TRX_REFERENCE_NUMBER,
		TRX_AMOUNT,
		CCY,
		TRX_DR_CR,
		STATUS
	)
	SELECT
		A.PKID,
		A.TRX_CODE,
		A.TRX_DATE,
		A.FACILITY_NUMBER,
		A.PKID AS TRX_REFERENCE_NUMBER,
		A.TRX_AMOUNT,
		A.CCY,
		TRX_DR_CR,
		STATUS
	FROM IFRS_TRX_FACILITY_HEADER A
	/* join ke transaction param untuk tau dia fee/cost  dan normal balance nya */
	INNER JOIN (SELECT DISTINCT TRX_CODE,IFRS_TXN_CLASS,CCY FROM IFRS_MASTER_TRANSACTION_PARAM) C
	on A.TRX_CODE=C.TRX_CODE
	AND (C.CCY='ALL' OR A.CCY=C.CCY)
	AND A.STATUS = 'ACT'
	WHERE A.TRX_DATE = V_CURRDATE
	and
	(
	(C.IFRS_TXN_CLASS='FEE' and A.TRX_DR_CR='D')
	or
	(C.IFRS_TXN_CLASS='COST' and A.TRX_DR_CR='C')
	)
	GROUP BY
	A.PKID,
	A.TRX_CODE,
	A.TRX_DATE,
	A.FACILITY_NUMBER,
	A.TRX_AMOUNT,
	A.CCY,
	TRX_DR_CR,
	STATUS;

	COMMIT;

	-- =========================================================
	-- GET REFERENCE NUMBER
	-- =========================================================

	EXECUTE IMMEDIATE 'TRUNCATE TABLE TMP_FACILITY_REFERENCE';

	INSERT INTO TMP_FACILITY_REFERENCE
	(
		PKID_REVTO,
		PKID_REVFROM,
		TRX_CODE,
		TRX_AMOUNT,
		CCY,
		FACILITY_NUMBER
	)
	SELECT min(A.PKID) as PKID_REVTO,
		B.PKID AS PKID_REVFROM,
		A.TRX_CODE,
		A.TRX_AMOUNT,
		A.CCY,
		A.FACILITY_NUMBER
	FROM IFRS_TRX_FACILITY_HEADER A
	JOIN TMP_FACILITY_REVERSAL B
	ON A.TRX_CODE=B.TRX_CODE
		AND A.TRX_AMOUNT=B.TRX_AMOUNT
		AND A.CCY=B.CCY
		AND A.FACILITY_NUMBER=B.FACILITY_NUMBER
	JOIN (SELECT DISTINCT TRX_CODE,IFRS_TXN_CLASS,CCY FROM IFRS_MASTER_TRANSACTION_PARAM) C
	on A.TRX_CODE=C.TRX_CODE
	AND (A.CCY = C.CCY
	or C.CCY='ALL')
	WHERE
		 (
	(C.IFRS_TXN_CLASS='FEE' and A.TRX_DR_CR='C')
	or
	(C.IFRS_TXN_CLASS='COST' and A.TRX_DR_CR='D')
	)
	AND A.PKID not IN (SELECT DISTINCT REVID FROM IFRS_TRX_FACILITY_HEADER where revid is not null)
	group by
	B.PKID,A.TRX_CODE,A.TRX_AMOUNT,A.CCY,A.FACILITY_NUMBER;

	COMMIT;

	-- =========================================================
	-- UPDATE REVID
	-- =========================================================
	MERGE INTO IFRS_TRX_FACILITY_HEADER A
	USING TMP_FACILITY_REFERENCE B
	ON (A.PKID=B.PKID_REVFROM AND A.TRX_DATE = V_CURRDATE)
	WHEN MATCHED THEN
	UPDATE SET A.REVID = B.PKID_REVTO
		, STATUS = 'REV';

	COMMIT;

	-- =========================================================
	-- INSERT REVERSAL TO IFRS_TRX_FACILITY_DETAIL
	-- =========================================================

	EXECUTE IMMEDIATE 'TRUNCATE TABLE TMP_IFRS_TRANSACTION_DAILY';

	INSERT INTO TMP_IFRS_TRANSACTION_DAILY
	(
		DOWNLOAD_DATE,
		EFFECTIVE_DATE,
		MASTERID,
		ACCOUNT_NUMBER,
		FACILITY_NUMBER,
		CUSTOMER_NUMBER,
		BRANCH_CODE,
		DATA_SOURCE,
		PRD_TYPE,
		PRD_CODE,
		CCY,
		ORG_CCY_AMT,
		EQV_LCY_AMT,
		TRX_REFERENCE_NUMBER,
		TRX_CODE,
		TRX_LEVEL,
		TRX_DR_CR,
		EXC_RATE_ACC_TO_IDR,
		EXC_RATE_TRX_TO_IDR,
		ORG_INITIAL_OS_AMT,
		LOAN_START_DATE,
		LOAN_DUE_DATE,
		SOURCE_TABLE,
		MATURITY_DATE
	)
	SELECT
	V_CURRDATE AS DOWNLOAD_DATE,
	V_CURRDATE AS EFFECTIVE_DATE,
	MASTERID,
	ACCOUNT_NUMBER,
	A.FACILITY_NUMBER,
	CUSTOMER_NUMBER,
	BRANCH_CODE,
	DATA_SOURCE,
	PRD_TYPE,
	PRD_CODE,
	A.CCY,
	ORG_CCY_AMT,
	EQV_LCY_AMT,
	B.PKID_REVFROM AS TRX_REFERENCE_NUMBER,
	A.TRX_CODE,
	TRX_LEVEL,
	CASE A.TRX_DR_CR WHEN 'D' THEN 'C'
		WHEN 'C' THEN 'D' END AS TRX_DR_CR,
	EXC_RATE_ACC_TO_IDR,
	EXC_RATE_TRX_TO_IDR,
	ORG_INITIAL_OS_AMT,
	LOAN_START_DATE,
	LOAN_DUE_DATE,
	SOURCE_TABLE,
	MATURITY_DATE
	FROM IFRS_TRX_FACILITY_DETAIL A
	JOIN TMP_FACILITY_REFERENCE B
	ON B.PKID_REVTO=A.TRX_REFERENCE_NUMBER
	WHERE TRX_LEVEL='FAC';

	COMMIT;

	INSERT INTO IFRS_TRX_FACILITY_DETAIL
	(
		DOWNLOAD_DATE,
		EFFECTIVE_DATE,
		MASTERID,
		ACCOUNT_NUMBER,
		FACILITY_NUMBER,
		CUSTOMER_NUMBER,
		BRANCH_CODE,
		DATA_SOURCE,
		PRD_TYPE,
		PRD_CODE,
		CCY,
		ORG_CCY_AMT,
		EQV_LCY_AMT,
		TRX_REFERENCE_NUMBER,
		TRX_CODE,
		TRX_LEVEL,
		TRX_DR_CR,
		EXC_RATE_ACC_TO_IDR,
		EXC_RATE_TRX_TO_IDR,
		ORG_INITIAL_OS_AMT,
		LOAN_START_DATE,
		LOAN_DUE_DATE,
		SOURCE_TABLE,
		MATURITY_DATE
	)
	SELECT
		DOWNLOAD_DATE,
		EFFECTIVE_DATE,
		MASTERID,
		ACCOUNT_NUMBER,
		FACILITY_NUMBER,
		CUSTOMER_NUMBER,
		BRANCH_CODE,
		DATA_SOURCE,
		PRD_TYPE,
		PRD_CODE,
		CCY,
		ORG_CCY_AMT,
		EQV_LCY_AMT,
		TRX_REFERENCE_NUMBER,
		TRX_CODE,
		TRX_LEVEL,
		TRX_DR_CR,
		EXC_RATE_ACC_TO_IDR,
		EXC_RATE_TRX_TO_IDR,
		ORG_INITIAL_OS_AMT,
		LOAN_START_DATE,
		LOAN_DUE_DATE,
		SOURCE_TABLE,
		MATURITY_DATE
	FROM TMP_IFRS_TRANSACTION_DAILY;

	COMMIT;

	/*****************************
		UPDATE STATUS
	 *****************************/

	UPDATE IFRS_TRX_FACILITY_HEADER
	SET ALOC=0,
		UNALOC=TRX_AMOUNT
	WHERE DOWNLOAD_DATE = V_CURRDATE
		AND REVID IS NULL;

	COMMIT;

	/*****************************
		INITIAL
	 *****************************/
	EXECUTE IMMEDIATE 'TRUNCATE TABLE TMP_IFRS_TRX_PRORATE';

	IF (V_FUNCROUND >= 1) THEN
		INSERT INTO TMP_IFRS_TRX_PRORATE
		SELECT
		A.*,
		LAG(A.SUM_TOTAL_ALOC) OVER (PARTITION BY A.PKID ORDER BY A.PKID,(A.INITIAL_OUTSTANDING * A.EXC_RATE_ACC_TO_IDR) DESC,A.ACCOUNT_NUMBER) PREV_TOTAL_ALOC,
		   CASE WHEN A.UNALOC - SUM_TOTAL_ALOC < 0 THEN
				CASE
					WHEN LAG(A.SUM_TOTAL_ALOC) OVER (PARTITION BY A.PKID ORDER BY A.PKID,(A.INITIAL_OUTSTANDING * A.EXC_RATE_ACC_TO_IDR) DESC,A.ACCOUNT_NUMBER) IS NULL
						THEN A.UNALOC
					WHEN A.UNALOC - LAG(A.SUM_TOTAL_ALOC) OVER (PARTITION BY A.PKID ORDER BY A.PKID,(A.INITIAL_OUTSTANDING * A.EXC_RATE_ACC_TO_IDR) DESC,A.ACCOUNT_NUMBER) < 0
						THEN 0
					ELSE
					A.UNALOC - LAG(A.SUM_TOTAL_ALOC) OVER (PARTITION BY A.PKID ORDER BY A.PKID,(A.INITIAL_OUTSTANDING * A.EXC_RATE_ACC_TO_IDR) DESC,A.ACCOUNT_NUMBER)
				  END
			  ELSE
			  --A.ALOC
			   CASE WHEN TRUNC(A.UNALOC - SUM_TOTAL_ALOC, V_ROUND) < V_DIFF_DIGIT_DECIMAL
				THEN
					A.ALOC + TRUNC(A.UNALOC -SUM_TOTAL_ALOC, V_ROUND)
					ELSE
					A.ALOC
				END
			  END ALOC_AFTER
		FROM(
				SELECT  B.EXCHANGE_RATE,
				   B.DOWNLOAD_DATE
				  ,A.TRX_DATE EFFECTIVE_DATE
				  ,A.MATURITY_DATE
				  ,B.MASTERID
				  ,B.ACCOUNT_NUMBER
				  ,A.FACILITY_NUMBER
				  ,B.CUSTOMER_NUMBER
				  ,B.BRANCH_CODE
				  ,B.DATA_SOURCE
				  ,B.PRODUCT_TYPE PRD_TYPE
				  ,B.PRODUCT_CODE PRD_CODE
				  ,A.TRX_CODE
				  ,B.CURRENCY   CCY
				  ,NULL EVENT_CODE
				  ,A.PKID TRX_REFERENCE_NUMBER
				  ,NULL ORG_CCY_AMT
				  ,NULL EQV_LCY_AMT
				  ,NULL TRX_SOURCE
				  ,NULL INTERNAL_NO
				  ,B.REVOLVING_FLAG
				  ,SYSTIMESTAMP CREATED_DATE
				  ,'FAC' TRX_LEVEL
				  ,A.TRX_DR_CR
				  ,B.EXCHANGE_RATE EXC_RATE_ACC_TO_IDR
				  ,C.RATE_AMOUNT EXC_RATE_TRX_TO_IDR
				  ,NULL ORG_INITIAL_OS_AMT
				  , TRUNC((TRUNC((CAST(B.INITIAL_OUTSTANDING AS BINARY_DOUBLE) * B.EXCHANGE_RATE), V_ROUND)
					/TRUNC((A.PLAFOND * C.RATE_AMOUNT), V_ROUND)
					* TRUNC((A.TRX_AMOUNT * C.RATE_AMOUNT), V_ROUND)), V_ROUND)  AS ALOC
				  ,TRUNC((A.UNALOC * C.RATE_AMOUNT), V_ROUND) AS UNALOC
				  ,LOAN_START_DATE
				  ,LOAN_DUE_DATE
				  ,NULL SOURCE_TABLE
				  ,A.PKID,B.INITIAL_OUTSTANDING
				  ,A.PLAFOND
				  ,TRUNC((SUM(TRUNC((TRUNC((CAST(B.INITIAL_OUTSTANDING AS BINARY_DOUBLE) * B.EXCHANGE_RATE), V_ROUND)
					/TRUNC((A.PLAFOND * C.RATE_AMOUNT), V_ROUND)
					* TRUNC((A.TRX_AMOUNT * C.RATE_AMOUNT), V_ROUND)), V_ROUND) )
					OVER (PARTITION BY A.PKID ORDER BY A.PKID,(B.INITIAL_OUTSTANDING * B.EXCHANGE_RATE) DESC,B.ACCOUNT_NUMBER)), V_ROUND)
					AS SUM_TOTAL_ALOC
				FROM IFRS_TRX_FACILITY_HEADER A
				INNER JOIN IFRS_MASTER_ACCOUNT B
				ON A.FACILITY_NUMBER = B.FACILITY_NUMBER
				AND B.DOWNLOAD_DATE = V_CURRDATE
					AND B.ACCOUNT_STATUS = 'A'
					AND A.REVID IS NULL
					AND A.STATUS = 'ACT'
				INNER JOIN IFRS_MASTER_EXCHANGE_RATE C
				ON B.DOWNLOAD_DATE=C.DOWNLOAD_DATE
					AND C.DOWNLOAD_DATE=V_CURRDATE
					AND A.CCY = C.CURRENCY
				WHERE NOT EXISTS (
					SELECT  * FROM IFRS_TRX_FACILITY_DETAIL C
					WHERE C.TRX_REFERENCE_NUMBER = A.PKID
					AND B.MASTERID = C.MASTERID
					AND A.FACILITY_NUMBER = C.FACILITY_NUMBER
					)
					AND NOT EXISTS (SELECT * FROM IFRS_TRX_FACILITY_HEADER C
									WHERE C.REVID = A.PKID
									AND C.DOWNLOAD_DATE <=V_CURRDATE)
					AND A.DOWNLOAD_DATE <=V_CURRDATE
				 ) A;
	ELSE
		INSERT INTO TMP_IFRS_TRX_PRORATE
		SELECT
		A.*,
		LAG(A.SUM_TOTAL_ALOC) OVER (PARTITION BY A.PKID ORDER BY A.PKID,(A.INITIAL_OUTSTANDING * A.EXC_RATE_ACC_TO_IDR) DESC,A.ACCOUNT_NUMBER) PREV_TOTAL_ALOC,
		   CASE WHEN A.UNALOC - SUM_TOTAL_ALOC < 0 THEN
				CASE
					WHEN LAG(A.SUM_TOTAL_ALOC) OVER (PARTITION BY A.PKID ORDER BY A.PKID,(A.INITIAL_OUTSTANDING * A.EXC_RATE_ACC_TO_IDR) DESC,A.ACCOUNT_NUMBER) IS NULL
						THEN A.UNALOC
					WHEN A.UNALOC - LAG(A.SUM_TOTAL_ALOC) OVER (PARTITION BY A.PKID ORDER BY A.PKID,(A.INITIAL_OUTSTANDING * A.EXC_RATE_ACC_TO_IDR) DESC,A.ACCOUNT_NUMBER) < 0
						THEN 0
					ELSE
					A.UNALOC - LAG(A.SUM_TOTAL_ALOC) OVER (PARTITION BY A.PKID ORDER BY A.PKID,(A.INITIAL_OUTSTANDING * A.EXC_RATE_ACC_TO_IDR) DESC,A.ACCOUNT_NUMBER)
				  END
			  ELSE
			  --A.ALOC
			   CASE WHEN ROUND((A.UNALOC -SUM_TOTAL_ALOC), V_ROUND) < V_DIFF_DIGIT_DECIMAL
				THEN
					A.ALOC + ROUND((A.UNALOC -SUM_TOTAL_ALOC), V_ROUND)
					ELSE
					A.ALOC
				END
			  END ALOC_AFTER
		FROM(
				SELECT  B.EXCHANGE_RATE,
				   B.DOWNLOAD_DATE
				  ,A.TRX_DATE EFFECTIVE_DATE
				  ,A.MATURITY_DATE
				  ,B.MASTERID
				  ,B.ACCOUNT_NUMBER
				  ,A.FACILITY_NUMBER
				  ,B.CUSTOMER_NUMBER
				  ,B.BRANCH_CODE
				  ,B.DATA_SOURCE
				  ,B.PRODUCT_TYPE     PRD_TYPE
				  ,B.PRODUCT_CODE    PRD_CODE
				  ,A.TRX_CODE
				  ,B.CURRENCY   CCY
				  ,NULL EVENT_CODE
				  ,A.PKID TRX_REFERENCE_NUMBER
				  ,NULL ORG_CCY_AMT
				  ,NULL EQV_LCY_AMT
				  ,NULL TRX_SOURCE
				  ,NULL INTERNAL_NO
				  ,B.REVOLVING_FLAG
				  ,SYSTIMESTAMP CREATED_DATE
				  ,'FAC'TRX_LEVEL
				  ,A.TRX_DR_CR
				  ,B.EXCHANGE_RATE EXC_RATE_ACC_TO_IDR
				  ,C.RATE_AMOUNT EXC_RATE_TRX_TO_IDR
				  ,NULL ORG_INITIAL_OS_AMT
				  , ROUND((ROUND((CAST(B.INITIAL_OUTSTANDING AS BINARY_DOUBLE) * B.EXCHANGE_RATE), V_ROUND)
					/ROUND((A.PLAFOND * C.RATE_AMOUNT), V_ROUND)
					* ROUND((A.TRX_AMOUNT * C.RATE_AMOUNT), V_ROUND)), V_ROUND)  AS ALOC
				  ,ROUND((A.UNALOC * C.RATE_AMOUNT), V_ROUND) AS UNALOC
				  ,LOAN_START_DATE
				  ,LOAN_DUE_DATE
				  ,NULL SOURCE_TABLE
				  ,A.PKID,B.INITIAL_OUTSTANDING
				  ,A.PLAFOND
				  ,ROUND((SUM(ROUND((ROUND((CAST(B.INITIAL_OUTSTANDING AS BINARY_DOUBLE) * B.EXCHANGE_RATE), V_ROUND)
					/ROUND((A.PLAFOND * C.RATE_AMOUNT), V_ROUND)
					* ROUND((A.TRX_AMOUNT * C.RATE_AMOUNT), V_ROUND)), V_ROUND) )
					OVER (PARTITION BY A.PKID ORDER BY A.PKID,(B.INITIAL_OUTSTANDING * B.EXCHANGE_RATE) DESC,B.ACCOUNT_NUMBER)), V_ROUND)
					AS SUM_TOTAL_ALOC
				FROM IFRS_TRX_FACILITY_HEADER A
				INNER JOIN IFRS_MASTER_ACCOUNT B
				ON A.FACILITY_NUMBER = B.FACILITY_NUMBER
				AND B.DOWNLOAD_DATE = V_CURRDATE
					AND B.ACCOUNT_STATUS = 'A'
					AND A.REVID IS NULL
					AND A.STATUS = 'ACT'
				INNER JOIN IFRS_MASTER_EXCHANGE_RATE C
				ON B.DOWNLOAD_DATE=C.DOWNLOAD_DATE
					AND C.DOWNLOAD_DATE=V_CURRDATE
					AND A.CCY = C.CURRENCY
				WHERE NOT EXISTS (
					SELECT  * FROM IFRS_TRX_FACILITY_DETAIL C
					WHERE C.TRX_REFERENCE_NUMBER = A.PKID
					AND B.MASTERID = C.MASTERID
					AND A.FACILITY_NUMBER = C.FACILITY_NUMBER
					)
					AND NOT EXISTS (SELECT * FROM IFRS_TRX_FACILITY_HEADER C
									WHERE C.REVID = A.PKID
									AND C.DOWNLOAD_DATE <=V_CURRDATE)
					AND A.DOWNLOAD_DATE <=V_CURRDATE
				 ) A;
	END IF;

	COMMIT;

	/*****************************
	 UPDATE ALOC_AMOUNT ON PARENT
	 *****************************/

	MERGE INTO IFRS_TRX_FACILITY_HEADER A
	USING
	(SELECT DOWNLOAD_DATE,
	        FACILITY_NUMBER,
	        TRX_REFERENCE_NUMBER,
			SUM(ALOC_AFTER/EXC_RATE_TRX_TO_IDR) ALOC
		FROM TMP_IFRS_TRX_PRORATE
		GROUP BY  DOWNLOAD_DATE,FACILITY_NUMBER, TRX_REFERENCE_NUMBER
	) B
	ON (
	    A.FACILITY_NUMBER = B.FACILITY_NUMBER
        AND A.DOWNLOAD_DATE = B.DOWNLOAD_DATE
        AND A.DOWNLOAD_DATE = V_CURRDATE
        AND A.PKID = B.TRX_REFERENCE_NUMBER
        )
	WHEN MATCHED THEN
	UPDATE SET A.ALOC = A.ALOC + B.ALOC
		, A.UNALOC = A.UNALOC - B.ALOC;

	COMMIT;

	/*****************************
	 UPDATE STATUS IF CLOSE
	 *****************************/

	UPDATE IFRS_TRX_FACILITY_HEADER
	SET STATUS = 'CLS'
	WHERE DOWNLOAD_DATE = V_CURRDATE
		AND STATUS = 'ACT'
		AND UNALOC = 0
		AND TRX_AMOUNT = ALOC;

	COMMIT;

	/*****************************
	 INSERT INTO DETAIL
	 *****************************/

	INSERT INTO IFRS_TRX_FACILITY_DETAIL
	(
	   DOWNLOAD_DATE
      ,EFFECTIVE_DATE
      ,MATURITY_DATE
      ,MASTERID
      ,ACCOUNT_NUMBER
      ,FACILITY_NUMBER
      ,CUSTOMER_NUMBER
      ,BRANCH_CODE
      ,DATA_SOURCE
      ,PRD_TYPE
      ,PRD_CODE
      ,TRX_CODE
      ,CCY
      ,EVENT_CODE
      ,TRX_REFERENCE_NUMBER
      ,ORG_CCY_AMT
      ,EQV_LCY_AMT
      ,TRX_SOURCE
      ,INTERNAL_NO
      ,REVOLVING_FLAG
      ,CREATED_DATE
      ,TRX_LEVEL
      ,TRX_DR_CR
      ,EXC_RATE_ACC_TO_IDR
      ,EXC_RATE_TRX_TO_IDR
      ,ORG_INITIAL_OS_AMT
      ,LOAN_START_DATE
      ,LOAN_DUE_DATE
      ,SOURCE_TABLE
	  )
	SELECT
	   DOWNLOAD_DATE
      ,EFFECTIVE_DATE
      ,MATURITY_DATE
      ,MASTERID
      ,ACCOUNT_NUMBER
      ,FACILITY_NUMBER
      ,CUSTOMER_NUMBER
      ,BRANCH_CODE
      ,DATA_SOURCE
      ,PRD_TYPE
      ,PRD_CODE
      ,TRX_CODE
      ,CCY
      ,EVENT_CODE
      ,TRX_REFERENCE_NUMBER
      ,CASE WHEN V_FUNCROUND > 0 THEN
        TRUNC(ALOC_AFTER / EXC_RATE_ACC_TO_IDR, V_ROUND)
      ELSE
        ROUND(ALOC_AFTER / EXC_RATE_ACC_TO_IDR, V_ROUND)
      END ORG_CCY_AMT
      ,ALOC_AFTER EQV_LCY_AMT
      ,TRX_SOURCE
      ,INTERNAL_NO
      ,REVOLVING_FLAG
      ,CREATED_DATE
      ,TRX_LEVEL
      ,TRX_DR_CR
      ,EXC_RATE_ACC_TO_IDR
      ,EXC_RATE_TRX_TO_IDR
      ,INITIAL_OUTSTANDING ORG_INITIAL_OS_AMT
      ,LOAN_START_DATE
      ,LOAN_DUE_DATE
      ,SOURCE_TABLE
	FROM TMP_IFRS_TRX_PRORATE
	WHERE ALOC_AFTER <> 0;

	COMMIT;

	/*****************************
	INSERT INTO TRANSACTION DAILY
	*****************************/
	DELETE FROM IFRS_TRANSACTION_DAILY
	WHERE DOWNLOAD_DATE >= V_CURRDATE
	AND TRX_LEVEL = 'FAC';

	COMMIT;

	INSERT INTO IFRS_TRANSACTION_DAILY
	(
		DOWNLOAD_DATE
		,EFFECTIVE_DATE
		,MATURITY_DATE
		,MASTERID
		,ACCOUNT_NUMBER
		,FACILITY_NUMBER
		,CUSTOMER_NUMBER
		,BRANCH_CODE
		,DATA_SOURCE
		,PRD_TYPE
		,PRD_CODE
		,TRX_CODE
		,CCY
		,EVENT_CODE
		,TRX_REFERENCE_NUMBER
		,ORG_CCY_AMT
		,EQV_LCY_AMT
		,DEBET_CREDIT_FLAG
		,TRX_SOURCE
		,INTERNAL_NO
		,REVOLVING_FLAG
		,CREATED_DATE
		,SOURCE_TABLE
		,TRX_LEVEL
	)
	SELECT DOWNLOAD_DATE
      ,EFFECTIVE_DATE
      ,MATURITY_DATE
      ,MASTERID
      ,ACCOUNT_NUMBER
      ,FACILITY_NUMBER
      ,CUSTOMER_NUMBER
      ,BRANCH_CODE
      ,DATA_SOURCE
      ,PRD_TYPE
      ,PRD_CODE
      ,TRX_CODE
      ,CCY
      ,EVENT_CODE
      ,TRX_REFERENCE_NUMBER
      ,ORG_CCY_AMT
      ,EQV_LCY_AMT
      ,TRX_DR_CR AS DEBET_CREDIT_FLAG
      ,TRX_SOURCE
      ,INTERNAL_NO
      ,REVOLVING_FLAG
      ,CREATED_DATE
      ,'TRX DAILY' SOURCE_TABLE
      ,TRX_LEVEL
    FROM IFRS_TRX_FACILITY_DETAIL;

	COMMIT;
END;